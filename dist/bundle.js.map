{"version":3,"file":"bundle.js","sources":["../src/7_basic/index.ts"],"sourcesContent":["\r\n// class Animal {\r\n//   constructor(public name: string, public age: number) { }\r\n// }\r\n\r\n// class Person {\r\n//   constructor(public name: string, public age: number) { }\r\n// }\r\n\r\n// type IClazz = new(name: string, age: number) => any\r\n// interface IClazz<T> {\r\n//   new(name: string, age: number): T;\r\n// }\r\n\r\n// function createInstance<T>(target: IClazz<T>, name: string, age: number) {\r\n//   return new target(name, age);\r\n// }\r\n\r\n// ts 中使用的时候确定类型，可以通过泛型 (传递的类型) T K U M N O P\r\n// const animal = createInstance<Person>(Animal, 'cat', 10);\r\n\r\n// 根据提供的数据生成对应长度的数组\r\n// function createArray<U>(len: number, val: U) {\r\n//   let result = [];\r\n\r\n//   for (let i = 0; i < len; i ++) {\r\n//     result.push(val)\r\n//   }\r\n\r\n//   return result;\r\n// }\r\n\r\n// let r = createArray(3, 1);\r\n\r\n\r\n// 两个泛型\r\n\r\n// function swap<T, K>(tuple: [T, K]): [K, T] {\r\n//   return [tuple[1], tuple[0]];\r\n// }\r\n\r\n// type ISwap = <T, K>(tuple: [T, K]) => [K, T]\r\n\r\n// interface ISwap {\r\n//   <T, K>(tuple: [T, K]): [K, T]\r\n// }\r\n\r\n// let swap: ISwap = (tuple) => {\r\n//   return [tuple[1], tuple[0]]\r\n// }\r\n\r\n// let r2 = swap(['abc', 123]); // => 123, abc\r\n\r\n\r\n// const forEach = <T>(arr: T[], cb: (item: any, index: number) => void) => {\r\n//   for (let i = 0; i < arr.length; i ++) {\r\n//     cb(arr[i], i);\r\n//   }\r\n// }\r\n\r\n\r\n// 泛型使用的时候传递类型，可以直接推导，但是内部调用的时候没有确定类型\r\n// type ICb<T> = (item: T, index: number) => void\r\n// type IForEach = <T>(arr: T[], cb: ICb<T>) => void\r\n// const forEach: IForEach = (arr, cb) => {\r\n//   for (let i = 0; i < arr.length; i++) {\r\n//     cb(arr[i], i);\r\n//   }\r\n// }\r\n\r\n// forEach([1, 2, 3, 'a', 'b', 'c'], function (item, index) {\r\n//   console.log(item, index);\r\n// })\r\n// 写在前面，就表示使用类型的时候传参，写到函数的前面意味着调用函数的时候传递参数\r\n\r\n// _______________________________________________________________\r\n\r\n// 泛型是有默认值的\r\n// 在使用一些联合类型的时候， 会使用泛型\r\n\r\ntype Union<T = boolean> = T | number | string;\r\n\r\nlet union: Union = true;\r\n\r\n// 泛型约束 要求传递的参数必须符合要求  \r\n// A extends B 要求， A 是 B 的 子类型或者同类型\r\n\r\nfunction handle<T extends string | number>(val: T): T {\r\n  return val;\r\n}\r\n\r\nlet r = handle('abc');\r\n\r\n\r\ninterface IWithLen {\r\n  length: number\r\n}\r\n\r\n\r\nfunction handle2<T extends IWithLen>(val: T) {\r\n  return val.length;\r\n}\r\nhandle2({\r\n  a: 1,\r\n  length: 2\r\n})\r\n\r\n/**\r\n * 什么叫子 什么叫父\r\n * 对于对象而言，子的类型结构可以比父亲多的\r\n * 子 继承 父\r\n */\r\n\r\n// function getVal<T> (obj: T, key: keyof T) {\r\n// }\r\n\r\nfunction getVal<T, K extends keyof T>(obj: T, key: K) {\r\n}\r\n\r\ngetVal({ name: 'xulei', age: 30 }, \"age\");\r\n\r\n\r\n// 通过 泛型 坑位 来占位置\r\n\r\ninterface ILoginResponse<T> {\r\n  code: number;\r\n  massage?: string;\r\n  data: T;\r\n}\r\n\r\ninterface ILoginData {\r\n  token: string;\r\n  roles: number[];\r\n}\r\n\r\nfunction toLogin(): ILoginResponse<ILoginData> {\r\n\r\n  return {\r\n    code: 200,\r\n    massage: '11',\r\n    data: {\r\n      token: 'token',\r\n      roles: [1, 2, 3]\r\n    },\r\n  }\r\n}\r\n\r\n// 获取最大值\r\nclass MyArray<T> {\r\n  private arr: T[] = [];\r\n\r\n  set(val: T) {\r\n    this.arr.push(val);\r\n  }\r\n\r\n  getMax(): T {\r\n    let arr = this.arr;\r\n    let max = arr[0];\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      let cur = arr[i];\r\n\r\n      if (cur > max) {\r\n        max = cur\r\n      }\r\n\r\n    }\r\n    return max;\r\n  }\r\n}\r\n\r\nlet arr = new MyArray<number>();\r\n\r\narr.set(1);\r\narr.set(100);\r\narr.set(300);\r\n\r\nconst res = arr.getMax()\r\nconsole.log(res);\r\n\r\nexport { };"],"names":[],"mappings":";;;;;EACA;EACA;EACA;EAgJA;EACA,MAAM,OAAO,CAAA;EAAb,IAAA,WAAA,GAAA;UACU,IAAG,CAAA,GAAA,GAAQ,EAAE,CAAC;OAoBvB;EAlBC,IAAA,GAAG,CAAC,GAAM,EAAA;EACR,QAAA,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;OACpB;MAED,MAAM,GAAA;EACJ,QAAA,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;EACnB,QAAA,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;EAEjB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;EACnC,YAAA,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;EAEjB,YAAA,IAAI,GAAG,GAAG,GAAG,EAAE;kBACb,GAAG,GAAG,GAAG,CAAA;eACV;WAEF;EACD,QAAA,OAAO,GAAG,CAAC;OACZ;EACF,CAAA;EAED,IAAI,GAAG,GAAG,IAAI,OAAO,EAAU,CAAC;EAEhC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACX,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACb,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAEb,MAAM,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAA;EACxB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;;;;;;"}